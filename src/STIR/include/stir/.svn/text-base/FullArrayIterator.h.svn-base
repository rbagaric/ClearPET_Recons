//
// $Id: FullArrayIterator.h,v 1.7 2004/07/28 15:40:29 kris Exp $
//
#ifndef __stir_FullArrayIterator__H__
#define __stir_FullArrayIterator__H__

/*!
  \file 
 
  \brief This file declares the FullArrayIterator class.

  \author Kris Thielemans
  \author Alexey Zverovich
  \author PARAPET project

  $Date: 2004/07/28 15:40:29 $
  $Revision: 1.7 $
*/
/*
    Copyright (C) 2000 PARAPET partners
    Copyright (C) 2000- $Date: 2004/07/28 15:40:29 $, Hammersmith Imanet Ltd
    See STIR/LICENSE.txt for details
*/

#include "stir/common.h"
#include <iterator>
#ifndef STIR_NO_NAMESPACES
using std::size_t;
using std::ptrdiff_t;
using std::forward_iterator_tag;
#endif

START_NAMESPACE_STIR

/*!
  \ingroup Array
  \brief Class FullArrayIterator implements (forward) iterators that go 
  through all elements of an Array.

  \warning This class should never be used explicitly, but only through
  the typedefs Array::full_iterator et al.

  This implementation assumes that \a restiterT has begin_all() and end_all() members.
  Moreover, for the usual \c for loops to work, there is a requirement on how the 
  class that uses FullArrayIterator implements end_all(). See the implementation of
  Array::end_all(). 
  
  \internal
*/
template <typename topleveliterT, typename restiterT, typename elemT, typename _Ref, typename _Ptr>
class FullArrayIterator
{
public:
  typedef forward_iterator_tag iterator_category;
  typedef ptrdiff_t difference_type;

  typedef elemT value_type;
  typedef _Ref reference;
  typedef _Ptr pointer;  

public:
  //! default constructor
  inline FullArrayIterator();

  //! copy constructor
  inline FullArrayIterator(const FullArrayIterator&);
  //! constructor to initialise the members
  inline FullArrayIterator(const topleveliterT& top_level_iter, 
                           const topleveliterT& last_top_level_iter,
                           const restiterT& rest_iter,
                           const restiterT& last_rest_iter);

  //! constructor with 0 (only 0, not another number)
  /*! This is necessary to be able to set \a current_rest_iter in the case of 
      an empty range.  This should be used by Array::begin_all() and Array::end_all() 
      such that for an empty array, these 2 (full)iterators are guaranteed to be equal.
  
      Ideally, Array::end_all() would just call restiterT().
      However, when going down the recursion, you will end up with the '1D' case 
      where restiterT is an ordinary iterator, which in the case of Array<1,elemT> 
      is just an elemT*. Its default constructor does nothing.

      All these complications could be avoided by rewriting operator== as 
      indicated in the code there, but at the expense of worse performance.
  */    
  inline FullArrayIterator(unsigned);
  
  // assignment is generated by compiler
  //inline FullArrayIterator& operator=(const FullArrayIterator&);
  
  //! prefix increment
  inline FullArrayIterator& operator++();

  //! postfix increment
  inline FullArrayIterator operator++(int);

  //! comparison operator
  inline bool operator==(const FullArrayIterator&) const;
  inline bool operator!=(const FullArrayIterator&) const;
  
  //! dereferencing operator
  inline reference operator*() const;

  //! member-selection operator 
  inline pointer operator->() const;

private:   

  //! the \c topleveliterT iterator pointing to the current \a row
  topleveliterT current_top_level_iter;

  //! a \c topleveliterT iterator marking the end of the \a column
  topleveliterT last_top_level_iter;

  //! a \c restiterT iterator pointing to the current \a element in the \a row
  restiterT current_rest_iter;

  //! a \c restiterT iterator pointing to the end of the current \a row
  restiterT last_rest_iter;

};

END_NAMESPACE_STIR

#include "stir/FullArrayIterator.inl"

#endif
